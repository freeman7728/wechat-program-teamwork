图论点的入度，出度

eg：

小镇法官

#include<bits/stdc++.h>
using namespace std;

class Solution 
{
public:
    int findJudge(int n, vector<vector<int>>& trust) 
    {
        vector<int> inDegree(n+1,0);
        vector<int> outDegree(n+1,0);

        for(int i=0;i<trust.size();i++)
        {
            int start=trust[i][0];
            int end=trust[i][1];
    
            outDegree[start]++;
            inDegree[end]++;
    
        }
    
        for(int i=1;i<=n;i++)
        {
            if(outDegree[i]==0&&inDegree[i]==n-1)
            {
                return i;
            }
        }
    
        return -1;
    }

};

BFS 解决迷宫问题

bool BFS()
{
	pair<int,int> tp;
	queue<pair<int,int>> q;
	tp.first=0;
	tp.second=0;
	q.push(tp);
	

	space[0][0]=2;
	
	while(!q.empty())
	{
		tp=q.front();
		q.pop();
		
		if(tp.first==9&&tp.second==9)
		{
			while(!q.empty())
			{
				q.pop();
			}
			
			return true;
		}
		
		if(space[tp.first][tp.second+1]!=2&&space[tp.first][tp.second+1]!=1&&tp.second!=9)
		{
			space[tp.first][tp.second+1]=2;
			q.push(pair<int,int>(tp.first,tp.second+1));
		}
		
		if(space[tp.first+1][tp.second]!=2&&space[tp.first+1][tp.second]!=1&&tp.first!=9)
		{
			space[tp.first+1][tp.second]=2;
			q.push(pair<int,int>(tp.first+1,tp.second));
		}
		
		if(space[tp.first][tp.second-1]!=2&&space[tp.first][tp.second-1]!=1&&tp.second!=0)
		{
			space[tp.first][tp.second-1]=2;
			q.push(pair<int,int>(tp.first,tp.second-1));
		}
		
		if(space[tp.first-1][tp.second]!=2&&space[tp.first-1][tp.second]!=1&&tp.first!=0)
		{
			space[tp.first-1][tp.second]=2;
			q.push(pair<int,int>(tp.first-1,tp.second));
		}


​		
​	}
​	

	return false;

}



DFS解决迷宫问题

int DFS(int first,int second)
{
	int ans=0;
	if(first==9&&second==9)
	{
		return true;
	}
	

	if(space[first][second + 1] != 2 &&space[first][second + 1] != 1 && second != 9)
	{
		space[first][second + 1] = 2;
		ans = max(ans,DFS(first,second + 1));
	}	
	
	if(space[first + 1][second] != 2 &&space[first + 1][second] != 1 && first != 9)
	{
		space[first + 1][second] = 2;
		ans = max(ans,DFS(first + 1,second));
	}
	
	if(space[first][second - 1] != 2 &&space[first][second - 1] != 1 && second != 0)
	{
		space[first][second - 1] = 2;
		ans = max(ans,DFS(first,second - 1));
	}
	
	if(space[first - 1][second] != 2 &&space[first - 1][second] != 1 && first != 0)
	{
		space[first - 1][second] = 2;
		ans = max(ans,DFS(first - 1,second));
	}
		
		return ans;

}